---
title: "Taxonomic Assignment"
author: "Kimberly Ledger"
date: "2024-05-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-libraries}
library(tidyverse)
library(tidyr)
library(stringr)
rename <- dplyr::rename
```

## load output from taxonkit 
```{r load-output-from-taxonkit}
taxonomy <-read.delim("/home/kimberly.ledger/BeringSea_Arctic_eDNA/data/blastn/blastn_taxlineage.txt", header = FALSE, na.strings=c(""," ","NA"))

head(taxonomy)
```

## filter taxonomy by the ASVs that made it through data decontamination - NOT DOING THIS - keeping all ASVs for initial analysis
```{r}
#asv_table <- read.csv("/home/kimberly.ledger/BeringSea_Arctic_eDNA/data/asv_table.csv") %>%
#  select(!X) 

#taxonomy <- taxonomy %>%
#  filter(V1 %in% asv_table$ASV)
```


## clean up the header a bit
```{r}
# use the full taxonomy rather than the seq id to collapse identical entries
tax_df <- taxonomy %>%
  filter(V4 > 100) %>% # make sure all retained matches are >100 bp
  select(-V2, -V5, -V6, -V7, -V14, -V8, -V9, -V10, -V11, -V12, -V13, -V15, -V16) %>%  #remove unnecessary columns
  group_by(V1, V17) %>% # group by the sequence key and the full taxonomy to reduce duplicate entries
  unique() %>% # doing that reduced the number of entries
  rename(qseqid=V1, perc_id=V3, length=V4, taxonomy=V17) %>% #rename headers
  filter(perc_id > 98) %>% 
  filter(!is.na(taxonomy))
```

## calcualate the number of ASV's with taxonomic assignment
```{r how-many-total-ASVs-w-taxonomy}
tax_df %>% 
  ungroup() %>%
  select(qseqid) %>%
  unique() %>%
  nrow
```

## reformat table 
```{r}
# formatting the taxonomy variables
taxon_df <- tax_df %>%
  filter(str_detect(taxonomy, ";")) %>%
  separate(taxonomy, into=c("kingdom", "phylum", "class", "order", "family", "genus", "species"), sep = ";") %>% 
  filter(!grepl("sp\\.", species, ignore.case = TRUE)) %>%
  filter(!grepl("cf\\.", species, ignore.case = TRUE)) %>%
  filter(!grepl("aff\\.", species, ignore.case = TRUE)) %>%
  filter(!grepl(" x ", species, ignore.case = TRUE)) %>%         ### remove hybrids and unknown species assignments
  filter(!grepl("\\d", species))
```


## figure out what ASVs are unambiguously a single species
```{r}
single_spp_seqs <- taxon_df %>% 
  group_by(qseqid) %>%
  add_tally(name = "n_taxa") %>%
  filter(n_taxa == 1)
```

## remove the single-species seqs from the dataframe and then rank the hits by % identity for the remaining seqs
```{r}
seq_id_diff <- taxon_df %>%
  anti_join(., single_spp_seqs) %>%  ## comment out this line if there are no single species ASVs
  select(-length) %>%
  group_by(qseqid, species, genus, family, order, class, phylum, kingdom) %>%
    mutate(seq_percID = max(perc_id)) %>%
    group_by(qseqid, species, genus, family, order, class, phylum, kingdom, seq_percID) %>%
  summarise(max(seq_percID)) %>% # take just the top hit for each taxon (for each sequence)
  select(-`max(seq_percID)`) %>%
  ungroup() %>%
  group_by(qseqid) %>%
      mutate(id_rank = rank(desc(seq_percID), ties.method = "min")) %>% # rank the taxonomic hits per sequence by % id
       mutate(top_perc = max(seq_percID)) %>% # designate the highest % id for the best taxonomic hit in each sequence (in some, but not all cases, this is 100%)   %>%
      mutate(diff = top_perc - seq_percID) %>% # calculate the difference between the % identity of the top hit and each subsequent taxonomic hit
        arrange(diff)

seq_id_diff %>%
  filter(diff > 0)
```

Now you have the single best entry for each species for each sequence ranked and with the difference between the first and second ranked entries calculated.

For sequences with multiple top hits, where the difference between ranked taxa = 0, you will end up defaulting to genus- or family-level ID. We'll do the same for any sequences where the difference between the first and second ranked taxa is < 1%.

## Figure out which differences are **> 1%** and eliminate those first
```{r}
# filter out any taxa that are >1% less matching identity than the top taxonomic hit for a given sequence
to_remove_low_perc_hits <- seq_id_diff %>%
  ungroup() %>%
  group_by(qseqid) %>%
  filter(diff > 1)

keepers <- seq_id_diff %>%
  anti_join(to_remove_low_perc_hits)
```

## so now determine whether ASVs should be assigned to genus, family, order, etc. 
```{r}
singletons <- keepers %>%
  select(qseqid) %>%
  tally() %>%
  filter(n == 1)

# these are the seqs that now have only a single match
singleton_df <- singletons %>%
  left_join(keepers) %>%
  select(-n) %>%
  bind_rows(single_spp_seqs) %>% # combine the single spp data
  mutate(taxonomic_level = "species") %>%
  mutate(taxon = species)

## Genus-level matches
# remove the singletons from the bigger df 
single_genus <- keepers %>%
  anti_join(singleton_df)%>% # at best, these should be genus-level matches
  group_by(qseqid, genus) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single genus
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "genus") %>%
  mutate(taxon = genus)
  

## Family-level matches
single_family <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  group_by(qseqid, family) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single family
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "family") %>%
  mutate(taxon = family)


## Order-level matches
single_order <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  group_by(qseqid, order) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single order
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "order") %>%
  mutate(taxon = order)


## Class-level matches
single_class <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  group_by(qseqid, class) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single class
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "class") %>%
  mutate(taxon = class)


## Phylum-level matches
single_phylum <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  anti_join(single_class) %>%
  group_by(qseqid, phylum) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single phylum
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "phylum") %>%
  mutate(taxon = phylum)

# Kingdom level matches
single_kingdom <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  anti_join(single_class) %>%
  group_by(qseqid, kingdom) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single kingdom
  select(-n) %>%
  left_join(., keepers) %>%
  mutate(taxonomic_level = "kingdom") %>%
  mutate(taxon = kingdom)
```

## modify the singleton_df to include the right variable headers
```{r}
single_spp <- singleton_df %>%
  select(-perc_id, -length, -n_taxa) %>%
  mutate(taxonomic_level = "species") %>%
  mutate(taxon = species)
```

## recombine the full data set now that the appropriate level of taxonomy has been determined
```{r}
sorted_tax_df <- bind_rows(single_kingdom, single_phylum, single_class, single_order, single_family, single_genus, single_spp)
```

# now let's take a closer look at the assignments we are getting from inital blastn 

## what non-fish are here? 
```{r}
not_Actinopteri <- sorted_tax_df %>%
  filter(class != "Actinopteri") %>%
  select(species, genus, family, order, class, phylum) %>%
  unique()
```

## remove terrestrial/freshwater/out-of-range non-fish from data set 
```{r}
not_Actinopteri_keepers <- not_Actinopteri %>% 
  filter(order != "Galliformes") %>%  ### remove chicken, junglefowl 
  filter(species != "Synthliboramphus wumizusume") %>% ### remove japanese murrelet
  filter(!(family == "Petromyzontidae" & species != "Lethenteron camtschaticum")) %>% ### remove lamrey except Arctic lamprey 
  filter(species != "Bathycoccus prasinos") %>% ### remove a picoplankton
  filter(!(family == "Delphinidae" & species != "Lagenorhynchus obliquidens")) %>% ### remove dolphins expect Pacific white-sided 
  filter(!family == "Bovidae") %>% ### remove bovids
  filter(!family == "Suidae") %>% ### remove pigs 
  filter(!species == "Pusa sibirica") %>% ### remove Baikal seal 
  filter(!family == "Cervidae") %>% ### remove moose 
  filter(!family == "Hominidae") %>% ### remove humans
  filter(!family == "Canidae") %>% ### remove dog
  select(species) %>%
  rename(Species = species) %>%
  mutate(in_range = "yes")
```

## now look at the fish and figure out what taxa are in/out of our range
```{r}
to_check_range <- sorted_tax_df %>%
  filter(class == "Actinopteri") %>%
  select(species, genus, family, order, class, phylum) %>%
  unique()
```

## check ranges for species using rfishbase 
```{r}
#library(remotes)
#remotes::install_github("ropensci/rfishbase")
library(rfishbase)

#one-time download of all fishbase tables... this takes a bit 
fb_import()

#make a spp list 
spp_names <- to_check_range$species

#get distribution info 
spp_distribution <- distribution(spp_names) %>%
  select(Species, FAO) %>%
  unique()

#add column to designate if we will consider a species as "in range"- for this study, this will be NE Pacific and Arctic Ocean 
spp_distribution_range <- spp_distribution %>%
  mutate(in_range = ifelse(is.na(FAO), NA, "no"),
         in_range = ifelse(FAO == "Pacific, Northeast", "yes", in_range),
         in_range = ifelse(FAO == "Arctic Ocean", "yes", in_range))

#keep just a list of spp names and yes/no/NA for "in range"  - this way we can keep track of what spp didn't have any reference information in fishbase to determine range 
spp_range <- spp_distribution_range %>%
  select(Species, in_range) %>%
  unique()

#how many entries do not have range info? 
range_na <- spp_range %>%
  filter(is.na(in_range))
```

# some species do not have range info - manually determine if these species should be considered in range
```{r}
range_na <- range_na %>%
  mutate(in_range = ifelse(Species == "Ammodytes japonicus", "no", in_range),
         in_range = ifelse(Species == "Cleisthenes herzensteini", "no", in_range),
         in_range = ifelse(Species == "Gadus ogac", "no", in_range),
         in_range = ifelse(Species == "Myoxocephalus aenaeas", "no", in_range),
         in_range = ifelse(Species == "Kareius bicoloratus", "no", in_range),
         in_range = ifelse(Species == "Cottocomephorus grewingki", "no", in_range),
         in_range = ifelse(Species == "Sebastes cheni", "no", in_range),
         in_range = ifelse(Species == "Embassichthys bathybius", "yes", in_range),    ##new name is Microstomus bathybius
         in_range = ifelse(Species == "Pungitius kaibarae", "no", in_range),
         in_range = ifelse(Species == "Ulcina olrikii", "yes", in_range),  ### arctic alligatorfish - Aspidophoroides olrikii
         in_range = ifelse(Species == "Polypera greeni", "yes", in_range))  ## Liparis greeni
```

## manually change a few species that are not really in the range.. and combine dataframes
```{r}

in_range <- spp_range %>%
  mutate(in_range = ifelse(Species == "Gadus morhua", "no", in_range)) %>%
  filter(in_range == "yes")

also_in_range <- range_na %>%
  filter(in_range == "yes")

all_in_range <- in_range %>%
  bind_rows(also_in_range) %>%
  bind_rows(not_Actinopteri_keepers)

sorted_tax_df <- sorted_tax_df %>%
  filter(species %in% all_in_range$Species)
```

okay, now that out-of-range species have been removed, i need to remake the taxonomic table to reflect the more specific ids (hopefully)

## so now determine whether ASVs should be assigned to species genus, family, order, etc. 
```{r}
#remove taxon_level and taxon designations
sorted_tax_df <- sorted_tax_df %>%
  select(!taxonomic_level) %>%
  select(!taxon)

singletons <- sorted_tax_df %>%
  select(qseqid) %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1)

# these are the seqs that now have only a single match
singleton_df <- singletons %>%
  left_join(sorted_tax_df) %>%
  select(-n) %>%
  mutate(taxonomic_level = "species") %>%
  mutate(taxon = species)

## Genus-level matches
# remove the singletons from the bigger df 
single_genus <- sorted_tax_df %>%
  anti_join(singleton_df) %>% # at best, these should be genus-level matches
  group_by(qseqid, genus) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single genus
  select(-n) %>%
  left_join(., sorted_tax_df) %>%
  mutate(taxonomic_level = "genus") %>%
  mutate(taxon = genus)
  
## Family-level matches
single_family <- sorted_tax_df %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  group_by(qseqid, family) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single family
  select(-n) %>%
  left_join(., sorted_tax_df) %>%
  mutate(taxonomic_level = "family") %>%
  mutate(taxon = family)


## Order-level matches
single_order <- sorted_tax_df %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  group_by(qseqid, order) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single order
  select(-n) %>%
  left_join(., sorted_tax_df) %>%
  mutate(taxonomic_level = "order") %>%
  mutate(taxon = order)


## Class-level matches
single_class <- sorted_tax_df %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  group_by(qseqid, class) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single class
  select(-n) %>%
  left_join(., sorted_tax_df) %>%
  mutate(taxonomic_level = "class") %>%
  mutate(taxon = class)


## Phylum-level matches
single_phylum <- sorted_tax_df %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  anti_join(single_class) %>%
  group_by(qseqid, phylum) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single phylum
  select(-n) %>%
  left_join(., sorted_tax_df) %>%
  mutate(taxonomic_level = "phylum") %>%
  mutate(taxon = phylum)

# Kingdom level matches
single_kingdom <- sorted_tax_df %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus) %>%
  anti_join(single_family) %>%
  anti_join(single_order) %>%
  anti_join(single_class) %>%
  group_by(qseqid, kingdom) %>%
  tally() %>%
  ungroup() %>%
  group_by(qseqid) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single kingdom
  select(-n) %>%
  left_join(., sorted_tax_df) %>%
  mutate(taxonomic_level = "kingdom") %>%
  mutate(taxon = kingdom)
```

## modify the singleton_df to include the right variable headers
```{r}
single_spp <- singleton_df
```

## recombine the full data set now that the appropriate level of taxonomy has been determined
```{r}
filtered_tax_df <- bind_rows(single_kingdom, single_phylum, single_class, single_order, single_family, single_genus, single_spp)
```

## some more manual taxonomy checks..
taxon = Agonidae (family) - this is most likely Sarritor frenatus (Sawback poacher)
taxon = Ammodytes (genus) - Ammodytes personatus or Ammodytes hexapterus
taxon = Anoplarchus (genus) - Anoplarchus insignis or Anoplarchus purpurescens
taxon = Cottidae (family) - Myoxocephalus or Microcottus
ASV_0718 = Aptocyclus ventricosus (species)
ASV_0222 = Hemilepidotus hemilepidotus - might just want to lump with Hemilepidotus (genus)

okay so there are taxon that could be more species, instead of saying genus we could go with the two species it might be? 
and there are also some taxon at species level, that see more appropriate to lump with the next higher level... 

taxon = Perciformes (family) - this is one of two species (Leptoclinus maculatus or Zaprora silenus)

what's our interest in Pleuronectidae - lots of ASVs - try to tease apart?? 

need to rename Polypera greeni to be Liparis greeni 

Salvelinus - arctic char or dolly varden? 
only one asv to Sebastidae - just lump with Sebastes (genus)? 


## output a list of all the Gadidae ASVs
```{r}
gadidae <- filtered_tax_df %>%
  filter(family == "Gadidae") %>%
  select(qseqid) %>%
  unique()
```

## output a list of all the salmon ASVs
```{r}
salmon <- filtered_tax_df %>%
  filter(genus == "Oncorhynchus") %>%
  select(qseqid) %>%
  unique()
```

## filter fasta to be just the gadids 
```{r}
# Load the necessary libraries
library(Biostrings)

# Define the input and output file paths
fasta_file <- "/home/kimberly.ledger/BeringSea_Arctic_eDNA/data/dadasnake/filtered.seqs.fasta"
output_file <- "/home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/gadidae.fasta"

# Read the FASTA file
fasta_seqs <- readDNAStringSet(fasta_file)

# Create a list of ASV sequence headers
asv_headers <- gadidae$qseqid  # 

# Filter the FASTA sequences based on the ASV headers
gadidae_seqs <- fasta_seqs[names(fasta_seqs) %in% asv_headers]

# Write the filtered sequences to a new FASTA file
writeXStringSet(gadidae_seqs, filepath = output_file)
```

## filter fasta to be just the gadids 
```{r}
# Load the necessary libraries
library(Biostrings)

# Define the input and output file paths
fasta_file <- "/home/kimberly.ledger/BeringSea_Arctic_eDNA/data/dadasnake/filtered.seqs.fasta"
output_file <- "/home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/onchorhynchus.fasta"

# Read the FASTA file
fasta_seqs <- readDNAStringSet(fasta_file)

# Create a list of ASV sequence headers
asv_headers <- salmon$qseqid  

# Filter the FASTA sequences based on the ASV headers
salmon_seqs <- fasta_seqs[names(fasta_seqs) %in% asv_headers]

# Write the filtered sequences to a new FASTA file
writeXStringSet(salmon_seqs, filepath = output_file)
```

just so i can pick up on this without having to rerun all the code, let me export the filtered_tax_df
```{r}
#write.csv(filtered_tax_df, "/home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/tax_df_20240702.csv")
```



## Create output taxonomy data frames
```{r}
uncollapsed_taxonomy <- filtered_tax_df %>%
  select(-top_perc, -id_rank) %>%
  unique() %>%
  arrange(qseqid)

# and then collapse that down to just a single taxon per ASV
collapsed_taxonomy <- uncollapsed_taxonomy %>%
  select(qseqid, taxon, taxonomic_level) %>%
  unique() %>%
  rename(ASV = qseqid)
```


```{r}
write.csv(collapsed_taxonomy, "/home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/collapsed_tax_20240625.csv")
```

how many unique taxa? 
```{r}
length(unique(collapsed_taxonomy$taxon))
unique(collapsed_taxonomy$taxon)
```


okay, i also want to try the taxonomic assignment of the 12S expanded db.  

i ran blastn on the .fasta output of dadasnake  (/home/kimberly.ledger/BeringSea_Arctic_eDNA/data/dadasnake) ([kimberly.ledger@akc0ss-vu-134 dadasnake]$ nohup blastn -db /genetics/edna/mifishdb/mifish_expanded_db -query filtered.seqs.fasta -perc_identity 96 -qcov_hsp_perc 100 -num_threads 10 -out /home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/12S_expanded/blastnresults_out_fmt6 -outfmt '6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore sscinames staxids' ) 

I also uploaded the taxonomy associated with the rCRUX database to the VM: C:\Users\kimberly.ledger>scp C:\Users\kimberly.ledger\Desktop\12S_expanded.tar\12S_expanded\12S_expanded\derep_and_clean_db\12S_expanded_derep_and_clean_taxonomy.txt kimberly.ledger@161.55.97.134:/home/kimberly.ledger/AFSC_eDNA/rCRUX

load data 
```{r}
library(tidyverse)

## taxonomy 
tax <- read.delim("/home/kimberly.ledger/AFSC_eDNA/rCRUX/12S_expanded_derep_and_clean_taxonomy.txt", header = FALSE, na.strings=c(""," ","NA")) %>%
  separate(V2, into=c("kingdom", "phylum", "class", "order", "family", "genus", "species"), sep = ";") %>%
  rename(accession=V1)

## blast output 
blast <- read.delim("/home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/12S_expanded/blastnresults_out_fmt6", header = FALSE, na.strings=c(""," ","NA")) %>%
  select(-V5, -V6, -V7, -V8, -V9, -V10, -V11, -V12, -V13, -V14) %>%  #remove unnecessary columns
  rename(ASV=V1, accession=V2, pident=V3, length=V4) %>% #rename headers
  filter(length > 100) #%>% # make sure all retained matches are >100 bp
```

join taxonomy to blast output 
```{r}
taxon_df <- blast %>%
  left_join(tax, by = "accession")
```

for now i will just disregard any ASV without at least one >98% match 
```{r}
taxon_df <- taxon_df %>%
  filter(pident >= 98)
```

are there any ASVs are unambiguously a single species
```{r}
single_spp_seqs <- taxon_df %>% 
  group_by(ASV) %>%
  add_tally(name = "n_taxa") %>%
  filter(n_taxa == 1)
```

okay, there are quite a few (at least compared to when i used blast on the entire ncbi database previously, but many of these are for ASVs with high ID (i.e. low numbers of reads in the dataset overall, and likely ones removed during decontamination?)

now remove the single-species seqs from the dataframe and then rank the hits by % identity for the remaining seqs
```{r}
seq_id_diff <- taxon_df %>%
  anti_join(., single_spp_seqs) %>%  ## comment out this line if there are no single species ASVs
  select(-length) %>%
  group_by(ASV, species, genus, family, order, class, phylum, kingdom) %>%
    mutate(seq_percID = max(pident)) %>%
    group_by(ASV, species, genus, family, order, class, phylum, kingdom, seq_percID) %>%
  summarise(max(seq_percID)) %>% # take just the top hit for each taxon (for each sequence)
  select(-`max(seq_percID)`) %>%
  ungroup() %>%
  group_by(ASV) %>%
      mutate(id_rank = rank(desc(seq_percID), ties.method = "min")) %>% # rank the taxonomic hits per sequence by % id
       mutate(top_perc = max(seq_percID)) %>% # designate the highest % id for the best taxonomic hit in each sequence (in some, but not all cases, this is 100%)   
      mutate(diff = top_perc - seq_percID) %>% # calculate the difference between the % identity of the top hit and each subsequent taxonomic hit
        arrange(diff)
```

Now you have the single best entry for each species for each sequence ranked and with the difference between the first and second ranked entries calculated.

For sequences with multiple top hits, where the difference between ranked taxa = 0, you will end up defaulting to genus- or family-level ID. We'll do the same for any sequences where the difference betweeen the first and second ranked taxa is < 0.5% (i.e. less one basepair difference).

## Figure out which differences are > 1% and eliminate those first
```{r}
# filter out any taxa that are 0.5% less matching identity than the top taxonomic hit for a given sequence
to_remove_low_perc_hits <- seq_id_diff %>%
  ungroup() %>%
  group_by(ASV) %>%
  filter(diff > 1)

keepers <- seq_id_diff %>%
  anti_join(to_remove_low_perc_hits) %>%
  filter(kingdom != "NA")                  ### also remove cases where there is no taxonomic information 
```

## so now determine whether ASVs should be assigned to genus, family, order, etc. 
```{r}
singletons <- keepers %>%
  select(ASV) %>%
  tally() %>%
  filter(n == 1)

# these are the seqs that now have only a single match - though not all are SPECIES level assignments 
singleton_df <- singletons %>%
  left_join(keepers) %>%
  select(-n) %>%
  bind_rows(single_spp_seqs) %>% # combine the single spp data
  mutate(taxonomic_level = ifelse(species != "NA", "species", NA),
         taxonomic_level = ifelse(species == "NA", "genus", taxonomic_level),
         taxonomic_level = ifelse(genus == "NA", "family", taxonomic_level)) 

# now need to deal with ASVs that have more than one match 
# i want to take the conservative approach and go with the entry that less specific 

## Genus-level matches
same_genus <- keepers %>%
  anti_join(singleton_df) %>%
  group_by(ASV, genus) %>%
  tally() %>%
  ungroup() %>%
  group_by(ASV) %>%
  tally() %>%
  filter(n == 1) %>%
  select(-n)
  
keepers_genus <- keepers %>%
  anti_join(singleton_df) %>%
  select(-species) %>%
  unique()
    
single_genus <- same_genus %>%
  left_join(keepers_genus) %>%
  mutate(taxonomic_level = "genus") %>%
  mutate(species = NA) %>%
  mutate(taxon = genus)


## Family-level matches
same_family <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus, by = "ASV") %>%
  group_by(ASV, family) %>%
  tally() %>%
  ungroup() %>%
  group_by(ASV) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single family
  select(-n) 

keepers_family <- keepers %>%
  anti_join(singleton_df) %>%
  anti_join(single_genus, by = "ASV") %>%
  select(-species) %>%
  select(-genus) %>%
  unique()
    
single_family <- same_family %>%
  left_join(keepers_family) %>%
  mutate(taxonomic_level = "family") %>%
  mutate(species = NA) %>%
  mutate(genus = NA) %>%
  mutate(taxon = family)
  

## Order-level matches
same_order <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus, by = "ASV") %>%
  anti_join(single_family, by = "ASV") %>%
  group_by(ASV, order) %>%
  tally() %>%
  ungroup() %>%
  group_by(ASV) %>%
  tally() %>%
  filter(n == 1) %>% # seqs that match a single order
  select(-n) 

keepers_order <- keepers %>%
  anti_join(singleton_df) %>%
  anti_join(single_genus, by = "ASV") %>%
  anti_join(single_family, by = "ASV") %>%
  select(-species) %>%
  select(-genus) %>%
  select(-family) %>%
  unique()
    
single_order <- same_order %>%
  left_join(keepers_order) %>%
  mutate(taxonomic_level = "order") %>%
  mutate(species = NA) %>%
  mutate(genus = NA) %>%
  mutate(family = NA) %>%
  mutate(taxon = order)


## Class-level matches
same_class <- keepers %>%
  anti_join(singleton_df)%>%
  anti_join(single_genus, by = "ASV") %>%
  anti_join(single_family, by = "ASV") %>%
  anti_join(single_order, by = "ASV") %>%
  group_by(ASV, class) %>%
  tally() %>%
  ungroup() %>%
  group_by(ASV) %>%
  tally() %>% 
  filter(n == 1) %>% # seqs that match a single class
  select(-n) 

## okay good, nothing left! 
```

modify the singleton_df to include the right variable headers
```{r}
single_entry <- singleton_df %>%
  select(-accession, -length, -pident, -n_taxa) %>%
  mutate(taxon = ifelse(taxonomic_level == "species", species, NA),
           taxon = ifelse(taxonomic_level == "genus", genus, taxon),
           taxon = ifelse(taxonomic_level == "family", family, taxon))
```

recombine the full data set now that the appropriate level of taxonomy has been determined
```{r}
sorted_tax_df <- bind_rows(single_order, single_family, single_genus, single_entry) %>%
  select(ASV, taxon, taxonomic_level, species, genus, family, order, class, phylum, kingdom) %>%
  unique()
```


```{r}
#write.csv(sorted_tax_df, "/home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/12S_expanded/asv_taxonomy_customdb_blast.csv")
```


compare assignments - remember that i did more geographic filtering on the ncbi blast db that did not happen with the 12s custom db
load data
```{r}
custom_blast <- read.csv("/home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/12S_expanded/asv_taxonomy_customdb_blast.csv") %>%
  select(!X) %>%
  select(ASV, taxon, taxonomic_level)

ncbi_blast <- read.csv("/home/kimberly.ledger/BeringSea_Arctic_eDNA/outputs/collapsed_tax_20240625.csv") %>%
  select(!X) %>%
  #rename(ASV = qseqid) %>%
  select(ASV, taxon, taxonomic_level) %>%
  unique()
```

compare assignments 
```{r}
join_tax <- custom_blast %>%
  left_join(ncbi_blast, by = "ASV") 
```

x = custom db, y = ncbi db -**note there was more custom filtering based on range for the ncbi db results

overall results look very similar. 


do this: For consistency, all species names were matched to valid names on FishBase using the validate_names function in rfishbase. When a valid name was not found, the presence of a species in the study area was checked using the GBIF database (https://www.gbif.org/).

- in addition to fishbase distributions, these citations may help: https://www.marinespecies.org/arms/aphia.php?p=taxdetails%26id=10194
and exclude Atlantic Arctic species: Mecklenburg, C. W., Lynghammar, A., Johannesen, E., Byrkjedal, I., Christiansen, J. S., Dolgov, A. V., Karamushko, O. V., Mecklenburg, T. A., MÃ¸ller, P. R., Steinke, D., & Wienerroither, R. M. (2018). Marine fishes of the Arctic region. Conservation of Arctic Flora and Fauna.

- keep asv taxon assignments of unique ASVs that have the same genus/order/etc classifiation seperate. give them a # after the name. ie. Onchorhyncus 1 and Onchoryncus 2. 



